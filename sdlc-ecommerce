------------------------Criar o projeto

------------------------Definir os recursos (entidades)

products
users
orders
payments
reviews

------------------------Criar URIs para cada recurso
definir rotas (endpoints)

Products

http post /products
http get /products/{id}
http get /products/{id}/orders/{orderId}
http get /products/{id}/orders?page=1&limit=10
http get /products/{id}/orders/{orderId}
http get /products/{id}/reviews?page=1&limit=10
http get /products/search?page=1&limit=100&keyword=sample&minPrice=100&maxPrice=1000&color=red,black&specs=ram:8Go,ram:16Go
http put /products/{id}
http delete /products/{id}

users

http post /users
http get /users/{id}
http get /users?page=1&limit=100
http get /users/{id}/orders?page=1&limit=10
http get /users/{id}/reviews?page=1&limit=100
http get /users/search?page=1&limit=10&keyword=John&verified=true
http put /users/{id}
http delete /users{id}

Orders

http post /orders
http get  /orders?page=1&limit=100
http get /orders/{id}
http get /orders/{id}/reviews?page=1&limit=100
http put /orders/{id}
http delete /orders/{id}

Payments

http post /payments
http get /payments?page=1&limit=100
http get /payments/{id}
http get /payments/{paymentId}/orders?page=1&limit=100

Reviews

http post /reviews
http get /reviews?page=1&limit=100
http get /reviews/{id}
http get /reviews/search?page=1&limit=100&keyword=Excellent&startDate=1716794723000
http put /reviews/{id}
http delete /reviews/{id}

-------------------Representando recursos

Now, the next step is to work on the resource presentation. We need to have a common contract
between the server and the client on how data will be presented. In our API, we will use JSON format.

For our data representation, we will force our API to send to the client this unique format in JSON.

class ApiResponse {
    success: boolean,
    message: string,
    error?: HttpExcetion,
    data: any
}

-------------------atribuindo métodos HTTP
Três categorias:
getters - GET
setters - POST
mutators - PUT e DELETE

-------------------Criar módulos das entidades

-------------------Configurar o banco de dados

npm i @nestjs/typeorm typeorm pg
npm add @nestjs/typeorm typeorm pg

This will install the @nestjs/typeorm module, which is a NestJS module that integrates the
TypeORM library itself, and pg, which is a PostgreSQL client for Node.js.

Configurar o typeorm

import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { TypeOrmModule } from '@nestjs/typeorm';
@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'postgres',
      host: 'localhost',
      port: 5432,
      username: 'postgres',
      password: 'your_password',
      database: 'ecommerce_db',
      entities: [],
      synchronize: true,
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

Try this out

While this minimalist database works perfectly fine for now, 
there is room to improve it by leveraging the power of NestJS’s ConfigModule class following these simple steps:

1. Install the @nestjs/config package using npm.
2. Import the ConfigModule class and set it to global in the AppModule class’s imports array.
3. Instead of using TypeOrmModule’s forRoot() method, use forRootAsync(), which
will allow you to inject environment variables asynchronously.
4. Inject the ConfigService class isn forRootAsync’s inject property.
5. Replace hard-coded values with their equivalents in the .env file that you will have to create;
for example, instead of hard-coding the password, you can do something such as setting the
password to configService.get<string>('POSTGRES_PASSWORD') or however
you decide to name it in your .env file.
6. Test the app once again and make sure the app starts successfully